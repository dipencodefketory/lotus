# -*- coding: utf-8 -*-

from lotus import db
import basismodels
import requests
from requests.auth import HTTPBasicAuth
from lotus import env_vars_path
from os import environ
from dotenv import load_dotenv

load_dotenv(env_vars_path)
base_url = f'https://import.idealo.com/shop/{environ.get("IDEALO_OFFER_SHOP_ID")}'


def get_access_token():
    """
    Basic function to generate an access-token for further API-calls.
    :return: dictionary of the general form
        {'access_token': token, 'token_type': 'bearer', 'expires_in': 3599, 'scope': 'MERCHANTORDERAPI:READ_ALL MERCHANTORDERAPI:WRITE_ALL', 'shop_id': <shop_id>}.
    """
    header = {'Content-Type': 'application/x-www-form-urlencoded'}
    auth = requests.post('https://api.idealo.com/mer/businessaccount/api/v1/oauth/token', headers=header,
                         auth=HTTPBasicAuth(environ.get('IDEALO_OFFER_CLIENT_ID'), environ.get('IDEALO_OFFER_CLIENT_PW')), data={'grant_type': 'client_credentials'})
    try:
        auth = auth.json()
        return auth
    except Exception:
        raise ConnectionError('Idealo-Access-Token could not be generated.')


def get_offer(access_dict: dict, sku: str):
    """
    Function to retrieve an offer from Idealo identified by the given sku.
    :param access_dict: dict - access_dict as generated by get_access_token.
    :param sku: str - product's SKU as set with initial upload.
    :return: request response object given by the API containing a dictionary of the general form
        {
            "sku" : "ABC13222",
            "title" : "title",
            "price" : "12.80",
            "url" : "http://www.idealo.de/",
            "basePrice" : "1,99 € / 100g",
            "packagingUnit" : 5,
            "voucherCode" : "AUTO10 (10% Rabatt auf alle Produkte der Kategorie Autoreifen bis 31.12.!)",
            "branchId" : "branch123",
            "brand" : "Sony",
            "oens" : [ "VW,123 615 301", "BMW,876 647 9879" ],
            "categoryPath" : [ "Clothes, Shoes & Accessories > Men's Clothing > Shorts", "Men's Outdoor > Shorts" ],
            "description" : "Digitalkamera EOS D5300 mit 24 MP und optischem Bildstabilisator inklusive Teleobjektiv",
            "imageUrls" : [ "http://cdn.philips-hue-weiss-und-farbig-10w-e27.jpg", "http://cdn.produktbild_max/philips-hue-schwarz-10w-e27.jpg" ],
            "eans" : [ "5021851148742", "9484474842987" ],
            "hans" : [ "DMC-TZ10EB-K", "DMC-AB567C-J" ],
            "pzns" : [ "03919011", "06893269" ],
            "kbas" : [ "46988 205/55R16" ],
            "merchantName" : "Example merchant",
            "merchantId" : "123456",
            "paymentCosts" : {
                "CASH_IN_ADVANCE" : "0.00",
                "PAYPAL" : "1.23",
                "CREDIT_CARD" : "2.99",
                "INVOICE" : "0.00"
            },
            "deliveryCosts" : {
                "DHL" : "3.99",
                "DPD" : "3.80"
            },
            "deliveryComment" : "Abholung vor Ort möglich, Lieferung inklusive Altgerätentsorgung",
            "delivery" : "1-3 Werktage",
            "maxOrderProcessingTime" : 1,
            "freeReturnDays" : 20,
            "checkout" : true,
            "checkoutLimitPerPeriod" : 13,
            "quantityPerOrder" : 2,
            "minimumPrice" : "12.00",
            "fulfillmentType" : "FREIGHT_FORWARDER",
            "twoManHandlingFee" : "20.00",
            "disposalFee" : "40.00",
            "eec" : "A++",
            "energyLabels" : [ {
                "efficiencyClass" : "A",
                "spectrum" : "A-G",
                "labelUrl" : "http://www.link.to/label.jpg",
                "dataSheetUrl" : "http://www.example.com/datasheet.pdf",
                "version" : 1
            } ],
            "deposit" : "0.25",
            "size" : "small",
            "colour" : "black",
            "gender" : "neutral",
            "material" : "metal",
            "replica" : true,
            "used" : true,
            "download" : true,
            "dynamicProductAttributes" : {
                "19326" : [ "39" ],
                "22337" : [ "6" ]
            }
        }
        if successful (200), else
        ???.
    """
    if type(access_dict) != dict:
        raise TypeError('Variable access_dict must be of type dict.')
    elif type(sku) != str:
        raise TypeError('Variable sku must be of type str.')
    else:
        if 'access_token' not in access_dict or 'scope' not in access_dict:
            raise KeyError('The keys "access_token" and "scope" are missing from access_dict.')
        elif not sku:
            raise ValueError('Variable sku must have at least on character.')
        else:
            header = {"Authorization": "Bearer " + access_dict['access_token'], 'Accept': 'application/json', 'Content-Type': 'application/json; charset=UTF-8', 'scope': access_dict['scope']}
            return requests.get(f'{base_url}/offer/{sku}', headers=header)


def put_offer(access_dict: dict, product_id: int, sku: str, title: str, price: float, merchant_name: str, payment_costs: dict, delivery_costs: dict, checkout: bool, fulfillment_type: str, url: str = None,
              voucher_code: str = None, brand: str = None, category_path: list = None, description: str = None, image_urls: list = None, eans: list = None, hans: list = None,
              delivery_comment: str = None, delivery: str = None, max_order_processing_time: int = None, free_return_days: int = None, checkout_limit_per_period: int = None,
              quantity_per_order: int = None, minimum_price: float = None, size: str = None):
    """
    Function to create a new Idealo-offer.
    :param access_dict: dict - access_dict as generated by get_access_token.
    :param product_id: int - product's ID.
    :param sku: str - product's SKU as set with initial upload.
    :param title: str - at most 255 characters.
    :param price: float - positive float.
    :param merchant_name: str
    :param payment_costs: dict(str: float) - possible keys are CLICK_AND_BUY, CREDIT_CARD, CASH_IN_ADVANCE, CASH_ON_DELIVERY, DIRECT_DEBIT, GOOGLE_CHECKOUT, GIROPAY, INVOICE, MONEYBOOKERS,
    POSTAL_ORDER, POSTPAY, PAYPAL,PAYSAFECARD, SOFORTUEBERWEISUNG, AMAZON_PAYMENT, ECOTAX, ICLEAR, ELECTRONIC_PAYMENT_STANDARD. Values must be non-negative.
    :param delivery_costs: dict(str: float) - possible keys are DEUTSCHE_POST, DHL, DHL_EXPRESS, DHL_GO_GREEN, DHL_PACKSTATION, DOWNLOAD, DPD, FEDEX, GERMAN_EXPRESS_LOGISTICS, GLS, GLS_THINK_GREEN,
    HERMES, PICK_POINT, SPEDITION, TNT, TRANS_O_FLEX, UPS. Values must be non-negative.
    :param checkout: bool - defines whether or not an offer is available for direct checkout.
    :param fulfillment_type: str - must have one of the following values: "FREIGHT_FORWARDER", "PARCEL_SERVICE", "DOWNLOAD", "LETTER".
    :param url: str - url to the offer page in the shop. (optional)
    :param voucher_code: str - (optional)
    :param brand: str - (optional)
    :param category_path: list(str) - (optional)
    :param description: str - at most 1042 characters. (optional)
    :param image_urls: list(str) - (optional)
    :param eans: list(str) - (optional)
    :param hans: list(str) - (optional)
    :param delivery_comment: str - (optional)
    :param delivery: str - at most 1042 characters. (optional)
    :param max_order_processing_time: int - positive number. (optional)
    :param free_return_days: int - non-negative number (optional)
    :param checkout_limit_per_period:  int - non-negative number. Will be set to infinity if not provided. (optional)
    :param quantity_per_order:  int - positive number. Will be set to 25 if not provided. (optional)
    :param minimum_price: float - positive float. (optional)
    :param size: str - (optional)
    :return: request response object given by the API.
    """
    if category_path is None:
        category_path = []
    if image_urls is None:
        image_urls = []
    if eans is None:
        eans = []
    if hans is None:
        hans = []
    if type(access_dict) != dict:
        raise TypeError('Variable access_dict must be of type dict.')
    elif type(sku) != str:
        raise TypeError('Variable sku must be of type str.')
    elif type(title) != str:
        raise TypeError('Variable sku must be of type str.')
    elif type(price) != str:
        raise TypeError('Variable price must be of type str.')
    elif type(merchant_name) != str:
        raise TypeError('Variable merchant_name must be of type str.')
    elif type(payment_costs) != dict:
        raise TypeError('Variable payment_costs must be of type dict.')
    elif type(delivery_costs) != dict:
        raise TypeError('Variable delivery_costs must be of type dict.')
    elif type(checkout) != bool:
        raise TypeError('Variable checkout must be of type bool.')
    elif type(fulfillment_type) != str:
        raise TypeError('Variable fulfillment_type must be of type str.')
    elif url is not None and type(url) != str:
        raise TypeError('Optional variable url must be of type str.')
    elif voucher_code is not None and type(voucher_code) != str:
        raise TypeError('Optional variable voucher_code must be of type str.')
    elif brand is not None and type(brand) != str:
        raise TypeError('Optional variable brand must be of type str.')
    elif category_path is not None and type(category_path) != list:
        raise TypeError('Optional variable category_path must be of type list.')
    elif description is not None and type(description) != str:
        raise TypeError('Optional variable description must be of type str.')
    elif image_urls is not None and type(image_urls) != list:
        raise TypeError('Optional variable image_urls must be of type list.')
    elif eans is not None and type(eans) != list:
        raise TypeError('Optional variable eans must be of type list.')
    elif hans is not None and type(hans) != list:
        raise TypeError('Optional variable hans must be of type list.')
    elif delivery_comment is not None and type(delivery_comment) != str:
        raise TypeError('Optional variable delivery_comment must be of type str.')
    elif delivery is not None and type(delivery) != str:
        raise TypeError('Optional variable delivery must be of type str.')
    elif max_order_processing_time is not None and type(max_order_processing_time) != int:
        raise TypeError('Optional variable max_order_processing_time must be of type int.')
    elif free_return_days is not None and type(free_return_days) != int:
        raise TypeError('Optional variable free_return_days must be of type int.')
    elif checkout_limit_per_period is not None and type(checkout_limit_per_period) != int:
        raise TypeError('Optional variable checkout_limit_per_period must be of type int.')
    elif quantity_per_order is not None and type(quantity_per_order) != int:
        raise TypeError('Optional variable quantity_per_order must be of type int.')
    elif minimum_price is not None and type(minimum_price) != float:
        raise TypeError('Optional variable minimum_price must be of type float.')
    elif size is not None and type(size) != str:
        raise TypeError('Optional variable size must be of type str.')
    else:
        if 'access_token' not in access_dict or 'scope' not in access_dict:
            raise KeyError('The keys "access_token" and "scope" are missing from access_dict.')
        if not sku:
            raise ValueError('Variable sku must have at least on character.')
        if len(title) > 255:
            raise ValueError(f'Variable title must not have more than 255 characters.')
        if float(price) <= 0:
            raise ValueError(f'Variable price must be positive.')
        if description is not None:
            if len(description) > 1042:
                raise ValueError(f'Variable description must not have more than 1042 characters.')
        for key in payment_costs:
            if type(key) != str:
                raise TypeError('Keys of variable payment_costs must be of type str.')
            elif key not in ['CLICK_AND_BUY', 'CREDIT_CARD', 'CASH_IN_ADVANCE', 'CASH_ON_DELIVERY', 'DIRECT_DEBIT', 'GOOGLE_CHECKOUT', 'GIROPAY', 'INVOICE', 'MONEYBOOKERS', 'POSTAL_ORDER', 'POSTPAY',
                             'PAYPAL', 'PAYSAFECARD', 'SOFORTUEBERWEISUNG', 'AMAZON_PAYMENT', 'ECOTAX', 'ICLEAR', 'ELECTRONIC_PAYMENT_STANDARD']:
                raise ValueError('''Keys of variable payment_costs must be one of the following: CLICK_AND_BUY, CREDIT_CARD, CASH_IN_ADVANCE, CASH_ON_DELIVERY, DIRECT_DEBIT, GOOGLE_CHECKOUT,
                GIROPAY, INVOICE, MONEYBOOKERS, POSTAL_ORDER, POSTPAY, PAYPAL, PAYSAFECARD, SOFORTUEBERWEISUNG, AMAZON_PAYMENT, ECOTAX, ICLEAR, ELECTRONIC_PAYMENT_STANDARD.''')
            else:
                if type(payment_costs[key]) != str:
                    raise TypeError('Values of variable payment_costs must be of type str.')
                elif float(payment_costs[key]) < 0:
                    raise ValueError(f'Values of variable payment_costs must be non-negative.')
        for key in delivery_costs:
            if type(key) != str:
                raise TypeError('Keys of variable delivery_costs must be of type str.')
            elif key not in ['DEUTSCHE_POST', 'DHL', 'DHL_EXPRESS', 'DHL_GO_GREEN', 'DHL_PACKSTATION', 'DOWNLOAD', 'DPD', 'FEDEX', 'GERMAN_EXPRESS_LOGISTICS', 'GLS', 'GLS_THINK_GREEN', 'HERMES',
                             'PICK_POINT', 'SPEDITION', 'TNT', 'TRANS_O_FLEX', 'UPS']:
                raise ValueError('''Keys of variable delivery_costs must be one of the following: DEUTSCHE_POST, DHL, DHL_EXPRESS, DHL_GO_GREEN, DHL_PACKSTATION, DOWNLOAD, DPD, FEDEX, 
                GERMAN_EXPRESS_LOGISTICS, GLS, GLS_THINK_GREEN, HERMES, PICK_POINT, SPEDITION, TNT, TRANS_O_FLEX, UPS.''')
            else:
                if type(delivery_costs[key]) != str:
                    raise TypeError('Values of variable delivery_costs must be of type str.')
                elif float(delivery_costs[key]) < 0:
                    raise ValueError(f'Values of variable delivery_costs must be non-negative.')
        if fulfillment_type not in ["FREIGHT_FORWARDER", "PARCEL_SERVICE", "DOWNLOAD", "LETTER"]:
            raise ValueError(f'Variable fulfillment_type have one of the following values: "FREIGHT_FORWARDER", "PARCEL_SERVICE", "DOWNLOAD", "LETTER".')
        if delivery is not None:
            if len(delivery) > 1042:
                raise ValueError(f'Optional variable delivery must not have more than 1042 characters.')
        if max_order_processing_time is not None:
            if max_order_processing_time <= 0:
                raise ValueError(f'Optional variable max_order_processing_time must positive.')
        if free_return_days is not None:
            if free_return_days < 0:
                raise ValueError(f'Optional variable free_return_days must non-negative.')
        if checkout_limit_per_period is not None:
            if checkout_limit_per_period < 0:
                raise ValueError(f'Optional variable checkout_limit_per_period must non-negative.')
        if quantity_per_order is not None:
            if quantity_per_order < 0:
                raise ValueError(f'Optional variable quantity_per_order must positive.')
        if minimum_price is not None:
            if float(minimum_price) <= 0:
                raise ValueError(f'Optional variable minimum_price must positive.')
        data = {'sku': sku,
                'title': title,
                'price': price,
                'merchantName': merchant_name,
                'paymentCosts': payment_costs,
                'deliveryCosts': delivery_costs,
                'checkout': checkout,
                'fulfillmentType': fulfillment_type
                }
        if url:
            data['url'] = url
        if voucher_code:
            data['voucherCode'] = voucher_code
        if brand:
            data['brand'] = brand
        if category_path:
            data['categoryPath'] = category_path
        if description:
            data['description'] = description
        if image_urls:
            data['imageUrls'] = image_urls
        if eans:
            data['eans'] = eans
        if hans:
            data['hans'] = hans
        if delivery_comment:
            data['deliveryComment'] = delivery_comment
        if delivery:
            data['delivery'] = delivery
        if max_order_processing_time is not None:
            data['maxOrderProcessingTime'] = max_order_processing_time
        if free_return_days is not None:
            data['freeReturnDays'] = free_return_days
        if checkout_limit_per_period is not None:
            data['checkoutLimitPerPeriod'] = checkout_limit_per_period
        if quantity_per_order is not None:
            data['quantityPerOrder'] = quantity_per_order
        if minimum_price is not None:
            data['minimumPrice'] = '%0.2f' % minimum_price
        if size:
            data['size'] = size
        header = {"Authorization": "Bearer " + access_dict['access_token'], 'Accept': 'application/json', 'Content-Type': 'application/json; charset=UTF-8', 'scope': access_dict['scope']}
        r = requests.put(url=f'{base_url}/offer/{sku}', json=data, headers=header)
        db.session.add(basismodels.ProductUpdateLog(url=f'{base_url}/offer/{sku}', method='PUT', data=str(data), response=r.text, status_code=r.status_code, product_id=product_id, marketplace_id=1))
        db.session.commit()
        return r


def patch_offer(access_dict: dict, product_id: int, sku: str, title: str = None, price: float = None, merchant_name: str = None, checkout: bool = None, fulfillment_type: str = None, url: str = None,
                voucher_code: str = None, brand: str = None, category_path: list = None, description: str = None, image_urls: list = None, eans: list = None, hans: list = None,
                delivery_comment: str = None, delivery: str = None, max_order_processing_time: int = None, free_return_days: int = None, checkout_limit_per_period: int = None,
                quantity_per_order: int = None, minimum_price: float = None):
    """
    Function to update an existing Idealo-offer.
    :param access_dict: dict - access_dict as generated by get_access_token.
    :param product_id: int - product's ID.
    :param sku: str - product's SKU as set with initial upload.
    :param title: str - at most 255 characters. (optional)
    :param price: float - positive float. (optional)
    :param merchant_name: str (optional)
    :param checkout: bool - defines whether or not an offer is available for direct checkout. (optional)
    :param fulfillment_type: str - must have one of the following values: "FREIGHT_FORWARDER", "PARCEL_SERVICE", "DOWNLOAD", "LETTER". (optional)
    :param url: str - url to the offer page in the shop. (optional)
    :param voucher_code: str - (optional)
    :param brand: str - (optional)
    :param category_path: list(str) - (optional)
    :param description: str - at most 1042 characters. (optional)
    :param image_urls: list(str) - (optional)
    :param eans: list(str) - (optional)
    :param hans: list(str) - (optional)
    :param delivery_comment: str - (optional)
    :param delivery: str - at most 1042 characters. (optional)
    :param max_order_processing_time: int - positive number. (optional)
    :param free_return_days: int - non-negative number (optional)
    :param checkout_limit_per_period:  int - non-negative number. Will be set to infinity if not provided. (optional)
    :param quantity_per_order:  int - positive number. Will be set to 25 if not provided. (optional)
    :param minimum_price: float - positive float. (optional)
    :return: request response object given by the API.
    """
    if category_path is None:
        category_path = []
    if image_urls is None:
        image_urls = []
    if eans is None:
        eans = []
    if hans is None:
        hans = []
    if type(access_dict) != dict:
        raise TypeError('Variable access_dict must be of type dict.')
    elif type(sku) != str:
        raise TypeError('Variable sku must be of type str.')
    elif title is not None and type(title) != str:
        raise TypeError('Variable sku must be of type str.')
    elif price is not None and type(price) != float:
        raise TypeError('Variable price must be of type float.')
    elif merchant_name is not None and type(merchant_name) != str:
        raise TypeError('Variable merchant_name must be of type str.')
    elif checkout is not None and type(checkout) != bool:
        raise TypeError('Variable checkout must be of type bool.')
    elif fulfillment_type is not None and type(fulfillment_type) != str:
        raise TypeError('Variable fulfillment_type must be of type str.')
    elif url is not None and type(url) != str:
        raise TypeError('Optional variable url must be of type str.')
    elif voucher_code is not None and type(voucher_code) != str:
        raise TypeError('Optional variable voucher_code must be of type str.')
    elif brand is not None and type(brand) != str:
        raise TypeError('Optional variable brand must be of type str.')
    elif category_path is not None and type(category_path) != list:
        raise TypeError('Optional variable category_path must be of type list.')
    elif description is not None and type(description) != str:
        raise TypeError('Optional variable description must be of type str.')
    elif image_urls is not None and type(image_urls) != list:
        raise TypeError('Optional variable image_urls must be of type list.')
    elif eans is not None and type(eans) != list:
        raise TypeError('Optional variable eans must be of type list.')
    elif hans is not None and type(hans) != list:
        raise TypeError('Optional variable hans must be of type list.')
    elif delivery_comment is not None and type(delivery_comment) != str:
        raise TypeError('Optional variable delivery_comment must be of type str.')
    elif delivery is not None and type(delivery) != str:
        raise TypeError('Optional variable delivery must be of type str.')
    elif max_order_processing_time is not None and type(max_order_processing_time) != int:
        raise TypeError('Optional variable max_order_processing_time must be of type int.')
    elif free_return_days is not None and type(free_return_days) != int:
        raise TypeError('Optional variable free_return_days must be of type int.')
    elif checkout_limit_per_period is not None and type(checkout_limit_per_period) != int:
        raise TypeError('Optional variable checkout_limit_per_period must be of type int.')
    elif quantity_per_order is not None and type(quantity_per_order) != int:
        raise TypeError('Optional variable quantity_per_order must be of type int.')
    elif minimum_price is not None and type(minimum_price) != float:
        raise TypeError('Optional variable minimum_price must be of type float.')
    else:
        if 'access_token' not in access_dict or 'scope' not in access_dict:
            raise KeyError('The keys "access_token" and "scope" are missing from access_dict.')
        if not sku:
            raise ValueError('Variable sku must have at least on character.')
        if title is not None:
            if len(title) > 255:
                raise ValueError(f'Variable title must not have more than 255 characters.')
        if price is not None:
            if price <= 0:
                raise ValueError(f'Variable price must be positive.')
        if description is not None:
            if len(description) > 1042:
                raise ValueError(f'Variable description must not have more than 1042 characters.')
        if delivery is not None:
            if len(delivery) > 1042:
                raise ValueError(f'Optional variable delivery must not have more than 1042 characters.')
        if max_order_processing_time is not None:
            if max_order_processing_time <= 0:
                raise ValueError(f'Optional variable max_order_processing_time must positive.')
        if free_return_days is not None:
            if free_return_days < 0:
                raise ValueError(f'Optional variable free_return_days must non-negative.')
        if checkout_limit_per_period is not None:
            if checkout_limit_per_period < 0:
                raise ValueError(f'Optional variable checkout_limit_per_period must non-negative.')
        if quantity_per_order is not None:
            if quantity_per_order < 0:
                raise ValueError(f'Optional variable quantity_per_order must positive.')
        if minimum_price is not None:
            if minimum_price <= 0:
                raise ValueError(f'Optional variable minimum_price must positive.')
        data = {'sku': sku}
        if title:
            data['title'] = title
        if price is not None:
            data['price'] = '%0.2f' % price
        if merchant_name:
            data['merchant_name'] = merchant_name
        if checkout:
            data['checkout'] = checkout
        if fulfillment_type:
            data['fulfillment_type'] = fulfillment_type
        if url:
            data['url'] = url
        if voucher_code:
            data['voucherCode'] = voucher_code
        if brand:
            data['brand'] = brand
        if category_path:
            data['categoryPath'] = category_path
        if description:
            data['description'] = description
        if image_urls:
            data['imageUrls'] = image_urls
        if eans:
            data['eans'] = eans
        if hans:
            data['hans'] = hans
        if delivery_comment:
            data['deliveryComment'] = delivery_comment
        if delivery:
            data['delivery'] = delivery
        if max_order_processing_time is not None:
            data['maxOrderProcessingTime'] = max_order_processing_time
        if free_return_days is not None:
            data['freeReturnDays'] = free_return_days
        if checkout_limit_per_period is not None:
            data['checkoutLimitPerPeriod'] = checkout_limit_per_period
        if quantity_per_order is not None:
            data['quantityPerOrder'] = quantity_per_order
        if minimum_price is not None:
            data['minimumPrice'] = '%0.2f' % minimum_price
        header = {"Authorization": "Bearer " + access_dict['access_token'], 'Accept': 'application/json', 'Content-Type': 'application/json; charset=UTF-8', 'scope': access_dict['scope']}
        r = requests.patch(url=f'{base_url}/offer/{sku}', json=data, headers=header)
        db.session.add(basismodels.ProductUpdateLog(url=f'{base_url}/offer/{sku}', method='PUT', data=str(data), response=r.text, status_code=r.status_code, product_id=product_id, marketplace_id=1))
        db.session.commit()
        return r


def delete_offer(access_dict: dict, product_id: int, sku: str):
    """
    Function to retrieve delete an offer from Idealo identified by the given sku.
    :param access_dict: dict - access_dict as generated by get_access_token.
    :param product_id: int - product's ID.
    :param sku: str - product's SKU as set with initial upload.
    :return: request response object given by the API.
    """
    if type(access_dict) != dict:
        raise TypeError('Variable access_dict must be of type dict.')
    elif type(sku) != str:
        raise TypeError('Variable sku must be of type str.')
    else:
        if 'access_token' not in access_dict or 'scope' not in access_dict:
            raise KeyError('The keys "access_token" and "scope" are missing from access_dict.')
        elif not sku:
            raise ValueError('Variable sku must have at least on character.')
        header = {"Authorization": "Bearer " + access_dict['access_token'], 'Accept': 'application/json', 'Content-Type': 'application/json; charset=UTF-8', 'scope': access_dict['scope']}
        r = requests.delete(url=f'{base_url}/offer/{sku}', headers=header)
        db.session.add(basismodels.ProductUpdateLog(url=f'{base_url}/offer/{sku}', method='PUT', data='', response=r.text, status_code=r.status_code, product_id=product_id, marketplace_id=1))
        db.session.commit()
        return r
