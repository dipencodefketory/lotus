# -*- coding: utf-8 -*-

import requests
from requests.auth import HTTPBasicAuth
from datetime import datetime, timedelta
from lotus import env_vars_path
from os import environ
from dotenv import load_dotenv

load_dotenv(env_vars_path)
shop_id = environ.get('IDEALO_ORDER_SHOP_ID')
base_url = 'https://orders.idealo.com'


def get_access_token():
    """
    Basic function to generate an access-token for further API-calls.
    :return: dictionary of the general form
        {'access_token': token, 'token_type': 'bearer', 'expires_in': 3599, 'scope': 'MERCHANTORDERAPI:READ_ALL MERCHANTORDERAPI:WRITE_ALL', 'shop_id': 318578}.
    """
    header = {'Content-Type': 'application/x-www-form-urlencoded'}
    auth = requests.post(f'{base_url}/api/v2/oauth/token', headers=header, auth=HTTPBasicAuth(environ.get('IDEALO_ORDER_CLIENT_ID'), environ.get('IDEALO_ORDER_CLIENT_PW')),
                         data={'grant_type': 'client_credentials'})
    return auth.json()


def get_orders(access_dict: dict, status: list = list(['PROCESSING']), from_time: str = (datetime.now()-timedelta(days=7)).replace(hour=0, minute=0, second=0).strftime('%Y-%m-%dT%H:%MZ'),
               to_time: str = datetime.now().strftime('%Y-%m-%dT%H:%MZ'), page_number: int = 0, page_size: int=1000, acknowledged: bool = False):
    """
    Function to retrieve orders from Idealo based on given filters.
    :param access_dict: access_dict as generated by get_access_token.
    :param status: list - status of orders from (possible values: 'PROCESSING', 'COMPLETED', 'REVOKING', 'REVOKED', 'PARTIALLY_REVOKED') - optional -> standard: list(['PROCESSING'])
    :param from_time: str - datetime given in format '%Y-%m-%dT%H:%MZ' - optional -> standard: (datetime.now()-timedelta(days=7)).strftime('%Y-%m-%dT%H:%MZ')
    :param to_time: str - datetime given in format '%Y-%m-%dT%H:%MZ' - optional -> standard: datetime.now().strftime('%Y-%m-%dT%H:%MZ')
    :param page_number: int(0, inf) - optional -> standard: 0
    :param page_size: int(1, 1000) - optional -> standard: 1000
    :param acknowledged: bool - optional -> standard: False
    :return: response containing dictionary of the general form
        {"content" :
            [
                {"idealoOrderId" : "A1B2C3D4", "merchantOrderNumber" : "1234ABC", "created" : "2019-05-01T00:00:00Z", "updated" : "2019-05-01T00:00:00Z", "status" : "PROCESSING", "currency" : "EUR",
                "offersPrice" : "50.85", "grossPrice" : "53.84", "shippingCosts" : "2.99", "lineItems" :
                    [
                        {"title" : "Example offer 1", "price" : "30.55", "formerPrice" : "31.99", "priceRangeAmount" : "1.44", "quantity" : 1, "sku" : "product-sku-12345",
                        "merchantId" : "merchant_12345", "merchantName" : "Example Electronics Ltd", "merchantDeliveryText" : "Delivered within 3 working days"},
                        {"title" : "Example offer 2", "price" : "10.15", "quantity" : 2, "sku" : "product-sku-5648", "merchantId" : "merchant_12345", "merchantName" : "Example Electronics Ltd",
                        "merchantDeliveryText" : "Delivered within 3 working days"}
                    ],
                "customer" :
                    {"email" : "m-zvvtu596gbz00t0@checkout.idealo.de", "phone" : "030-1231234"},
                "payment" :
                    {"paymentMethod" : "IDEALO_CHECKOUT_PAYMENTS", "transactionId" : "acb-123"},
                "billingAddress" :
                    {"salutation" : "MR", "firstName" : "Max", "lastName" : "Mustermann", "addressLine1" : "Ritterstraße 11", "addressLine2" : "c/o idealo", "postalCode" : "10969", "city" : "Berlin",
                    "countryCode" : "DE"},
                "shippingAddress" :
                    {"salutation" : "MR", "firstName" : "Max", "lastName" : "Mustermann", "addressLine1" : "Ritterstraße 11", "addressLine2" : "c/o idealo", "postalCode" : "10969", "city" : "Berlin",
                    "countryCode" : "DE"},
                "fulfillment" :
                    {"method" : "POSTAL", "tracking" :
                        [
                            {"code" : "xyz1234", "carrier" : "Cargo"}
                        ],
                    "options" :
                        [
                            {"forwardOption" : "TWO_MAN_DELIVERY", "price" : "2.99"}
                        ]
                    },
                "refunds" :
                    [
                        {"refundId" : "example-refund-id", "refundTransactionId" : "example-refund-transaction-id", "status" : "OPEN", "currency" : "EUR", "refundAmount" : 1.99}
                    ],
                "voucher" :
                    {"code" : "FXWFGE (30%, max. 5 EUR)"}
                }
            ],
        "totalElements" : 1,
        "totalPages" : 1
        }
        if successful (???), else
        ???
    """
    if type(access_dict) != dict:
        print('Variable access_dict must be of type dict.')
        raise TypeError
    elif type(status) != list:
        print('Variable status must be of type list.')
        raise TypeError
    elif type(from_time) != str:
        print('Variable from_time must be of type str.')
        raise TypeError
    elif type(to_time) != str:
        print('Variable to_time must be of type str.')
        raise TypeError
    elif type(page_number) != int:
        print('Variable page_number must be of type int.')
        raise TypeError
    elif type(page_size) != int:
        print('Variable page_size must be of type int.')
        raise TypeError
    elif type(acknowledged) != bool:
        print('Variable acknowledged must be of type bool.')
        raise TypeError
    else:
        if 'access_token' not in access_dict or 'scope' not in access_dict:
            print('The keys "access_token" and "scope" are missing from access_dict.')
            raise KeyError
        elif any(el not in ['PROCESSING', 'COMPLETED', 'REVOKING', 'REVOKED', 'PARTIALLY_REVOKED'] for el in status):
            print('Invalid status. Possible values are PROCESSING, COMPLETED, REVOKING, REVOKED, PARTIALLY_REVOKED.')
            raise ValueError
        elif page_number < 0:
            print('Variable page_number must be greater or equal to 0.')
            raise ValueError
        elif page_size > 1000 or page_size < 1:
            print('Variable page_size must be at least 1 and at most 1000.')
            raise ValueError
        else:
            try:
                datetime.strptime(from_time, '%Y-%m-%dT%H:%MZ')     # checking format of from_time
                datetime.strptime(to_time, '%Y-%m-%dT%H:%MZ')       # checking format of to_time
                data = {"status": status, "from": from_time, "to": to_time, "pageNumber": page_number, "pageSize": page_size, "acknowledged": acknowledged}
                header = {"Authorization": "Bearer " + access_dict['access_token'], 'Accept': 'application/json', 'Content-Type': 'application/json; charset=UTF-8', 'scope': access_dict['scope']}
                return requests.get(url=f'{base_url}/api/v2/shops/{shop_id}/orders', headers=header, params=data)
            except ValueError:
                print('Variables from_time and to_time must be of format "%Y-%m-%dT%H:%MZ".')
                raise ValueError


def set_fulfil_info(access_dict: dict, idealo_order_id: str, carrier: str, tracking_code: str):
    """
    Function to set tracking-code of Idealo-order.
    :param access_dict: dict - access_dict as generated by get_access_token.
    :param idealo_order_id: str - idealo-order-id as given by Idealo.
    :param carrier: str(1, 31) - e.g. "Cargo", "Der Courier", "Deutsche Post", "DHL", "DPD", "FedEx", "GLS", "Hermes", "UPS"
    :param tracking_code: str(1, 127)
    :return: response with code ??? if successful, else ???
    """
    if type(access_dict) != dict:
        print('Variable access_dict must be of type dict.')
        raise TypeError
    elif type(idealo_order_id) != str:
        print('Variable idealo_order_id must be of type str.')
        raise TypeError
    elif type(carrier) != str:
        print('Variable carrier must be of type str.')
        raise TypeError
    elif type(tracking_code) != str:
        print('Variable tracking_code must be of type str.')
        raise TypeError
    else:
        if 'access_token' not in access_dict or 'scope' not in access_dict:
            print('The keys "access_token" and "scope" are missing from access_dict.')
            raise KeyError
        elif len(carrier) not in range(1, 32):
            print('Length of variable carrier must be at least 1 and at most 31.')
            raise ValueError
        elif len(tracking_code) not in range(1, 128):
            print('Length of variable carrier must be at least 1 and at most 127.')
            raise ValueError
        elif len(idealo_order_id) < 1:
            print('Variable idealo_order_id must be non-empty.')
            raise ValueError
        else:
            header = {"Authorization": "Bearer " + access_dict['access_token'], 'Accept': 'application/json', 'Content-Type': 'application/json; charset=UTF-8', 'scope': access_dict['scope']}
            return requests.post(url=f'{base_url}/api/v2/shops/{shop_id}/orders/{idealo_order_id}/fulfillment', headers=header, json={"carrier": carrier, "trackingCode": [tracking_code]})


def revoke_order(access_dict: dict, idealo_order_id: str, sku: str, reason: str, comment: str = None, remaining_quantity: int = None):
    """
    Function to revoke Idealo-orders.
    :param access_dict: dict - access_dict as generated by get_access_token.
    :param idealo_order_id: str - idealo-order-id as given by Idealo.
    :param sku: str - SKU of line-item to be revoked.
    :param reason: str - reason for revoking the order (possible values: 'MERCHANT_DECLINE', 'CUSTOMER_REVOKE', 'RETOUR')
    :param comment: str - optional
    :param remaining_quantity: int - optional -> if not set, all elements with given SKU will be revoked.
    :return: response with code ??? if successful, else ???
    """
    if type(access_dict) != dict:
        print('Variable access_dict must be of type dict.')
        raise TypeError
    elif type(idealo_order_id) != str:
        print('Variable idealo_order_id must be of type str.')
        raise TypeError
    elif type(sku) != str:
        print('Variable sku must be of type str.')
        raise TypeError
    elif type(reason) != str:
        print('Variable reason must be of type str.')
        raise TypeError
    elif comment is not None and type(comment) != str:
        print('Optional variable comment must be of type str.')
        raise TypeError
    elif remaining_quantity is not None and type(remaining_quantity) != int:
        print('Optional variable remaining_quantity must be of type int.')
        raise TypeError
    else:
        if 'access_token' not in access_dict or 'scope' not in access_dict:
            print('The keys "access_token" and "scope" are missing from access_dict.')
            raise KeyError
        elif reason not in ['MERCHANT_DECLINE', 'CUSTOMER_REVOKE', 'RETOUR']:
            print('Invalid reason. Possible values are MERCHANT_DECLINE, CUSTOMER_REVOKE, RETOUR.')
            raise ValueError
        else:
            header = {"Authorization": "Bearer " + access_dict['access_token'], 'Accept': 'application/json', 'Content-Type': 'application/json; charset=UTF-8', 'scope': access_dict['scope']}
            return requests.post(url=f'{base_url}/api/v2/shops/{shop_id}/orders/{idealo_order_id}/revocations', headers=header,
                                 json={"sku": sku, "remainingQuantity": remaining_quantity, "reason": reason, "comment": comment})


def refund_order(access_dict: dict, idealo_order_id: str, refund_amount: float, currency: str):
    """
    Function to refund orders paid with idealo checkout payments.
    :param access_dict: dict - access_dict as generated by get_access_token.
    :param idealo_order_id: str - idealo-order-id as given by Idealo.
    :param refund_amount: float - amount to be refunded.
    :param currency: str - ISO 4217 currency code (possible values: 'EUR')
    :return: response with code ??? if successful, else ???
    """
    if type(access_dict) != dict:
        print('Variable access_dict must be of type dict.')
        raise TypeError
    elif type(idealo_order_id) != str:
        print('Variable idealo_order_id must be of type str.')
        raise TypeError
    elif type(refund_amount) != float:
        print('Variable refund_amount must be of type float.')
        raise TypeError
    elif type(currency) != str:
        print('Variable currency must be of type str.')
        raise TypeError
    else:
        if 'access_token' not in access_dict or 'scope' not in access_dict:
            print('The keys "access_token" and "scope" are missing from access_dict.')
            raise KeyError
        elif refund_amount < 0.01:
            print('Variable refund_amount must be at least 0.01.')
            raise ValueError
        elif currency not in ['EUR']:
            print('Invalid currency. Possible values are EUR.')
            raise ValueError
        else:
            header = {"Authorization": "Bearer " + access_dict['access_token'], 'Accept': 'application/json', 'Content-Type': 'application/json; charset=UTF-8', 'scope': access_dict['scope']}
            return requests.post(url=f'{base_url}/api/v2/shops/{shop_id}/orders/{idealo_order_id}/refunds', headers=header, json={"refundAmount": refund_amount, "currency": currency})
